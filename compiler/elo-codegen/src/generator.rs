use std::{collections::HashMap, fmt::format};
use elo_ir::ir::{self, ValidatedProgram};

#[derive(Debug)]
pub struct Namespace {
    pub variables: HashMap<String, String>,
}

pub struct Generator {
    pub input: ValidatedProgram,
    pub output: String,
}

impl Generator {
    pub fn new(input: ValidatedProgram) -> Self {
        Self {
            input: input,
            output: String::from(HEAD),
        }
    }
}

const HEAD: &'static str = "//generated by Elo compiler\n//copyright(c) 2025 Marcio Dantas, Igor Ferreira\n#include<stdint.h>\n";

impl Generator {
    pub fn choose_type(&self, t: ir::Typing) -> Option<String> {
        return match t {
            ir::Typing::Primitive(ir::Primitive::I128) => Some("__int128".to_string()),
            ir::Typing::Primitive(ir::Primitive::I64) => Some("int64_t".to_string()),
            ir::Typing::Primitive(ir::Primitive::I32) => Some("int32_t".to_string()),
            ir::Typing::Primitive(ir::Primitive::I16) => Some("int16_t".to_string()),
            ir::Typing::Primitive(ir::Primitive::I8) => Some("int8_t".to_string()),
            ir::Typing::Primitive(ir::Primitive::Bool) => Some("bool".to_string()),
            ir::Typing::Primitive(ir::Primitive::U128) => Some("unsigned __int128".to_string()),
            ir::Typing::Primitive(ir::Primitive::U64) => Some("uint64_t".to_string()),
            ir::Typing::Primitive(ir::Primitive::U32) => Some("uint32_t".to_string()),
            ir::Typing::Primitive(ir::Primitive::U16) => Some("uint16_t".to_string()),
            ir::Typing::Primitive(ir::Primitive::U8) => Some("uint8_t".to_string()),
            ir::Typing::Primitive(ir::Primitive::F32) => Some("float".to_string()),
            ir::Typing::Primitive(ir::Primitive::F64) => Some("double".to_string()),
            // TODO: Make these int and uint to have the same size as the target architecture
            ir::Typing::Primitive(ir::Primitive::Int) => Some("intptr_t".to_string()),
            ir::Typing::Primitive(ir::Primitive::UInt) => Some("unsigned int".to_string()),
            // TODO: Make float have the size as the target architecture
            ir::Typing::Primitive(ir::Primitive::Float) => Some("float".to_string()),
            ir::Typing::Primitive(ir::Primitive::Str) => Some("char*".to_string()),
            ir::Typing::Pointer { typ } => Some(self.choose_type(*typ).unwrap() + "*"),
            ir::Typing::Void => Some("void".to_string()),
            _ => todo!(),
        };
    }

    // NOTE: I'm using an option here in case of a function call that returns void,
    // which is not a valid value in LLVM unfortunately.
    pub fn generate_expression(&mut self, expr: &ir::Expression) -> Option<String> {
        match expr {
            ir::Expression::Integer { value } => {
                return Some(value.to_string());
            }
            ir::Expression::Float { value } => {
                return Some(value.to_string());
            }
            ir::Expression::StringLiteral { value } => {
                // TODO: Make this a sized string, for now it's a null-terminated string for compatibility with C
                //       See elo-validation too for the *u8 typing
                return Some(format!("\"{}\"", value));
            }
            ir::Expression::Bool { value } => {
                return Some(if *value { "1" } else { "0" }.to_string());
            }
            ir::Expression::UnaryOperation { operator, operand } => {
                let op = self.generate_expression(operand).unwrap();
                match *operator {
                    ir::UnaryOperation::Neg => {
                        return Some(format!("-({})", op));
                    }
                    ir::UnaryOperation::BNot => {
                        return Some(format!("~({})", op));
                    }
                    ir::UnaryOperation::Not => {
                        return Some(format!("!({})", op));
                    }
                    ir::UnaryOperation::Addr => {
                        return Some(format!("&({})", op));
                    } // TODO: Implement dereference operator
                      // *x syntax to load a value from a pointer
                      // ir::UnaryOperation::Deref => {
                      //     let x = self.builder.build_load(op.into_pointer_value(), "addr").unwrap();
                      //     return Some(x.into());
                      // }
                }
            }
            ir::Expression::BinaryOperation {
                operator,
                left,
                right,
            } => {
                let lhs = self.generate_expression(left).unwrap();
                let rhs = self.generate_expression(right).unwrap();
                match *operator {
                    ir::BinaryOperation::Add => { 
                        return Some(format!("({lhs})+({rhs})"));
                    }
                    ir::BinaryOperation::Sub => {
                        return Some(format!("({lhs})-({rhs})"));
                    }
                    ir::BinaryOperation::Mul => {
                        return Some(format!("({lhs})*({rhs})"));
                    }
                    ir::BinaryOperation::Div => {
                        return Some(format!("({lhs})/({rhs})"));
                    }
                    _ => todo!(),
                }
            }
            ir::Expression::FunctionCall {
                function,
                arguments,
            } => {
                match function.as_ref() {
                    ir::Expression::Identifier { name } => {
                        let mut call = String::new();
                        call.push_str(name);
                        call.push('(');
                        for (i, arg) in arguments.iter().enumerate() {
                            let arg = self.generate_expression(arg).unwrap();
                            call.push_str(&arg);
                            if (i+1 < arguments.len()) { call.push(','); }
                        }
                        call.push(')');
                        return Some(call);
                    }
                    _ => todo!(),
                }
            }
            ir::Expression::Identifier { name } => {
                return Some(name.clone());
            }
            _ => todo!(),
        }
    }

    pub fn generate_from_node(
        &mut self,
        node: &mut ir::ValidatedNode,
        toplevel: bool,
    ) {
        match &mut node.stmt {
            ir::Statement::Constant { value, binding, typing } => {
                self.output.push_str("static ");
                self.output.push_str(self.choose_type(typing.clone()).unwrap().as_str());
                self.output.push_str(binding);
                self.output.push('=');
                let expr = self.generate_expression(value).unwrap();
                self.output.push_str(&expr);
                self.output.push(';');
            },
            ir::Statement::FnStatement(stmt) => {
                self.output.push_str(&(self.choose_type(stmt.ret.clone()).unwrap() + " "));
                self.output.push_str(&stmt.name);
                self.output.push('(');
                for (j, i) in stmt.arguments.iter().enumerate() {
                    self.output.push_str(&(self.choose_type(i.typing.clone()).unwrap() + " "));
                    self.output.push_str(&i.name);
                    if (j+1 < stmt.arguments.len()) { self.output.push(','); }
                }
                self.output.push_str("){\n");
                for mut i in std::mem::take(&mut stmt.block.content) {
                    self.generate_from_node(&mut i, false);
                    self.output.push('\n');
                }
                self.output.push('}');
            }
            ir::Statement::ExternFnStatement(stmt) => {
                self.output.push_str(&(self.choose_type(stmt.ret.clone()).unwrap() + " "));
                self.output.push_str(&stmt.name);
                self.output.push('(');
                for (j, i) in stmt.arguments.iter().enumerate() {
                    self.output.push_str(&(self.choose_type(i.typing.clone()).unwrap() + " "));
                    self.output.push_str(&i.name);
                    if (j+1 < stmt.arguments.len()) { self.output.push(','); }
                }
                if let true = stmt.variadic {
                    self.output.push_str(",...");
                }
                self.output.push_str(");");
            }
            ir::Statement::StructStatement(_stmt) => {
                todo!();
            }
            ir::Statement::EnumStatement(_stmt) => {
                todo!();
            }
            ir::Statement::Variable { binding, assignment, typing, mutable } if !toplevel => {
                let typ = self.choose_type(typing.clone()).unwrap();
                let expr = self.generate_expression(assignment).unwrap();
                self.output.push_str(&format!("{typ} {binding}={expr};"));
            }
            ir::Statement::ExpressionStatement(expr) => {
                let e = self.generate_expression(expr).unwrap();
                self.output.push_str(&e);
                self.output.push(';');
            }
            ir::Statement::ReturnStatement { value, typing } if !toplevel => {
                self.output.push_str("return");
                if let Some(value) = value {
                    let e = self.generate_expression(value).unwrap();
                    self.output.push_str(&format!(" {}", e));
                }
                self.output.push(';');
            }
            ir::Statement::IfStatement {
                condition,
                block_true,
                block_false,
            } => {
                let comparison = self.generate_expression(&condition).unwrap();
                self.output.push_str(&format!("if({}){{\n", comparison));
                for mut i in std::mem::take(&mut block_true.content) {
                    self.generate_from_node(&mut i, false);
                    self.output.push('\n');
                }
                self.output.push('}');
                if !block_false.content.is_empty() {
                    self.output.push_str("else{");
                    for mut i in std::mem::take(&mut block_false.content) {
                        self.generate_from_node(&mut i, false);
                        self.output.push('\n');
                    }
                    self.output.push('}');
                }
            }
            _ => todo!(),
        }
    }

    pub fn generate(&mut self) {
        for mut node in std::mem::take(&mut self.input.nodes) {
            self.generate_from_node(&mut node, true);
            self.output.push('\n');
        }
    }
}
