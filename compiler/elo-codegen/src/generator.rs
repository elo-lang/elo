use crate::c;
use elo_ir::ir::{self, Program};

pub struct Generator {
    pub input: Program,
    pub output: String,
}

impl Generator {
    pub fn new(input: Program) -> Self {
        Self {
            input: input,
            output: String::from(HEAD),
        }
    }
}

const HEAD: &'static str = "//generated by Elo compiler\n//copyright(c) 2025 Marcio Dantas, Igor Ferreira\n#include<stdint.h>\n";

impl Generator {
    pub fn choose_type(&self, t: ir::Typing) -> String {
        return match t {
            ir::Typing::Primitive(ir::Primitive::I128) => "__int128".to_string(),
            ir::Typing::Primitive(ir::Primitive::I64) => "int64_t".to_string(),
            ir::Typing::Primitive(ir::Primitive::I32) => "int32_t".to_string(),
            ir::Typing::Primitive(ir::Primitive::I16) => "int16_t".to_string(),
            ir::Typing::Primitive(ir::Primitive::I8) => "int8_t".to_string(),
            ir::Typing::Primitive(ir::Primitive::Bool) => "bool".to_string(),
            ir::Typing::Primitive(ir::Primitive::U128) => "unsigned __int128".to_string(),
            ir::Typing::Primitive(ir::Primitive::U64) => "uint64_t".to_string(),
            ir::Typing::Primitive(ir::Primitive::U32) => "uint32_t".to_string(),
            ir::Typing::Primitive(ir::Primitive::U16) => "uint16_t".to_string(),
            ir::Typing::Primitive(ir::Primitive::U8) => "uint8_t".to_string(),
            ir::Typing::Primitive(ir::Primitive::F32) => "float".to_string(),
            ir::Typing::Primitive(ir::Primitive::F64) => "double".to_string(),
            // TODO: Make these int and uint to have the same size as the target architecture
            ir::Typing::Primitive(ir::Primitive::Int) => "intptr_t".to_string(),
            ir::Typing::Primitive(ir::Primitive::UInt) => "uintptr_t".to_string(),
            // TODO: Make float have the size as the target architecture
            ir::Typing::Primitive(ir::Primitive::Float) => "float".to_string(),
            ir::Typing::Primitive(ir::Primitive::Str) => "char*".to_string(),
            ir::Typing::Primitive(ir::Primitive::Char) => "uint32_t".to_string(),
            ir::Typing::Pointer { typ } => self.choose_type(*typ) + "*",
            ir::Typing::Void => "void".to_string(),
            _ => todo!(),
        };
    }

    // NOTE: I'm using an option here in case of a function call that returns void,
    // which is not a valid value in LLVM unfortunately.
    pub fn generate_expression(&mut self, expr: &ir::Expression) -> String {
        match expr {
            ir::Expression::Integer { value } => value.to_string(),
            ir::Expression::Float { value } => value.to_string(),
            ir::Expression::StringLiteral { value } => format!("\"{}\"", value),
            ir::Expression::Bool { value } => {
                return if *value { "1" } else { "0" }.to_string();
            }
            ir::Expression::UnaryOperation { operator, operand } => {
                let op = self.generate_expression(operand);
                match *operator {
                    ir::UnaryOperation::Neg => c::build_unop(op, c::Unop::Neg),
                    ir::UnaryOperation::BNot => c::build_unop(op, c::Unop::BNot),
                    ir::UnaryOperation::Not => c::build_unop(op, c::Unop::Not),
                    ir::UnaryOperation::Addr => c::build_unop(op, c::Unop::Addr),
                    // TODO: Implement dereference operator
                }
            }
            ir::Expression::BinaryOperation {
                operator,
                left,
                right,
            } => {
                let lhs = self.generate_expression(left);
                let rhs = self.generate_expression(right);
                match *operator {
                    ir::BinaryOperation::Add => c::build_binop(lhs, rhs, c::Binop::Add),
                    ir::BinaryOperation::Sub => c::build_binop(lhs, rhs, c::Binop::Sub),
                    ir::BinaryOperation::Mul => c::build_binop(lhs, rhs, c::Binop::Mul),
                    ir::BinaryOperation::Div => c::build_binop(lhs, rhs, c::Binop::Div),
                    _ => todo!(),
                }
            }
            ir::Expression::FunctionCall {
                function,
                arguments,
            } => match function.as_ref() {
                ir::Expression::Identifier { name } => {
                    let arguments: Vec<String> = arguments
                        .iter()
                        .map(|x| self.generate_expression(x))
                        .collect();
                    let arguments = c::build_comma_list(arguments.as_slice());
                    return c::build_function_call(name.clone(), arguments);
                }
                _ => todo!(),
            },
            ir::Expression::Identifier { name } => name.clone(),
            _ => todo!(),
        }
    }

    pub fn generate_statement(&mut self, stmt: &mut ir::Statement) -> String {
        let mut output = String::new();
        match stmt {
            ir::Statement::Constant {
                value,
                binding,
                typing,
            } => {
                output.push_str("static ");
                output.push_str(self.choose_type(typing.clone()).as_str());
                output.push_str(&binding);
                output.push('=');
                let expr = self.generate_expression(&value);
                output.push_str(&expr);
                output.push(';');
            }
            ir::Statement::FnStatement(stmt) => {
                let r#return = self.choose_type(stmt.ret.clone());
                let name = stmt.name.clone();
                let mut arguments = Vec::new();
                for i in &stmt.arguments {
                    let t = self.choose_type(i.typing.clone());
                    let n = i.name.clone();
                    arguments.push(c::build_typed_field(t, n));
                }
                let arguments = c::build_comma_list(arguments.as_slice());
                let body = stmt
                    .block
                    .content
                    .iter_mut()
                    .map(|x| self.generate_statement(x))
                    .collect::<Vec<String>>();
                let body = c::build_statement_list(body.as_slice());
                output.push_str(&c::build_function_definition(
                    r#return,
                    name,
                    arguments,
                    stmt.variadic,
                    body,
                ));
            }
            ir::Statement::ExternFnStatement(stmt) => {
                let r#return = self.choose_type(stmt.ret.clone());
                let name = stmt.name.clone();
                let mut arguments = Vec::new();
                for i in &stmt.arguments {
                    let t = self.choose_type(i.typing.clone());
                    let n = i.name.clone();
                    arguments.push(c::build_typed_field(t, n));
                }
                let arguments = c::build_comma_list(arguments.as_slice());
                output.push_str(&c::build_function_declaration(
                    r#return,
                    name,
                    arguments,
                    stmt.variadic,
                ))
            }
            ir::Statement::StructStatement(_stmt) => {
                todo!();
            }
            ir::Statement::EnumStatement(_stmt) => {
                todo!();
            }
            ir::Statement::Variable {
                binding,
                assignment,
                typing,
            } => {
                let typ = self.choose_type(typing.clone());
                let expr = self.generate_expression(&assignment);
                output.push_str(&c::build_variable_definition(typ, binding.clone(), expr));
            }
            ir::Statement::ExpressionStatement(expr) => {
                let e = self.generate_expression(&expr);
                output.push_str(&e);
            }
            ir::Statement::ReturnStatement { value, typing: _ } => {
                let e = value.as_ref().map(|x| self.generate_expression(x));
                output.push_str(&c::build_return(e));
            }
            ir::Statement::IfStatement {
                condition,
                block_true,
                block_false,
            } => {
                let comparison = self.generate_expression(&condition);
                let r#true = block_true
                    .content
                    .iter_mut()
                    .map(|x| self.generate_statement(x))
                    .collect::<Vec<String>>();
                let r#true = c::build_statement_list(r#true.as_slice());

                let mut r#false = None;
                if !block_false.content.is_empty() {
                    let f = block_false
                        .content
                        .iter_mut()
                        .map(|x| self.generate_statement(x))
                        .collect::<Vec<String>>();
                    r#false = Some(c::build_statement_list(f.as_slice()));
                }
                output.push_str(&c::build_if(comparison, r#true, r#false));
            }
            _ => todo!(),
        };
        return output;
    }

    pub fn go(&mut self) {
        for mut node in std::mem::take(&mut self.input.nodes) {
            let node = self.generate_statement(&mut node);
            self.output.push_str(&node);
            self.output.push_str(";\n");
        }
    }
}
