use crate::c;
use elo_ir::ir::{self, Program};

pub struct Generator {
    pub input: Program,
    pub output: String,
}

impl Generator {
    pub fn new(input: Program) -> Self {
        Self {
            input: input,
            output: String::from(HEAD),
        }
    }
}

const HEAD: &'static str = "//generated by Elo compiler\n//copyright(c) 2025 Marcio Dantas, Igor Ferreira\n#include<stdint.h>\n";

// fn fnv_hash(text: &str) -> u32 {
//     const FNV_OFFSET_BASIS_32: u32 = 2166136261;
//     const FNV_PRIME_32: u32 = 16777619;
//     let mut hash = FNV_OFFSET_BASIS_32;
//     for byte in text.bytes() {
//         hash = hash.wrapping_mul(FNV_PRIME_32);
//         hash = hash ^ (byte as u32);
//     }
//     hash
// }

// fn mangle_function(name: &str) -> String {
//     if name == "main" {
//         // TODO: Rename this mangling result to be __elo__main
//         //       or something like that when implementing runtime
//         return String::from("main");
//     }
//     return format!("__elo__fn_{name}_{}", fnv_hash(name));
// }

impl Generator {
    pub fn choose_type(&self, t: &ir::Typing) -> String {
        return match t {
            ir::Typing::Primitive(ir::Primitive::I128) => "__int128".to_string(),
            ir::Typing::Primitive(ir::Primitive::I64) => "int64_t".to_string(),
            ir::Typing::Primitive(ir::Primitive::I32) => "int32_t".to_string(),
            ir::Typing::Primitive(ir::Primitive::I16) => "int16_t".to_string(),
            ir::Typing::Primitive(ir::Primitive::I8) => "int8_t".to_string(),
            ir::Typing::Primitive(ir::Primitive::Bool) => "bool".to_string(),
            ir::Typing::Primitive(ir::Primitive::U128) => "unsigned __int128".to_string(),
            ir::Typing::Primitive(ir::Primitive::U64) => "uint64_t".to_string(),
            ir::Typing::Primitive(ir::Primitive::U32) => "uint32_t".to_string(),
            ir::Typing::Primitive(ir::Primitive::U16) => "uint16_t".to_string(),
            ir::Typing::Primitive(ir::Primitive::U8) => "uint8_t".to_string(),
            ir::Typing::Primitive(ir::Primitive::F32) => "float".to_string(),
            ir::Typing::Primitive(ir::Primitive::F64) => "double".to_string(),
            // TODO: Make these int and uint to have the same size as the target architecture
            ir::Typing::Primitive(ir::Primitive::Int) => "intptr_t".to_string(),
            ir::Typing::Primitive(ir::Primitive::UInt) => "uintptr_t".to_string(),
            // TODO: Make float have the size as the target architecture
            ir::Typing::Primitive(ir::Primitive::Float) => "float".to_string(),
            ir::Typing::Primitive(ir::Primitive::Str) => "char*".to_string(),
            ir::Typing::Primitive(ir::Primitive::Char) => "uint32_t".to_string(),
            ir::Typing::Pointer { typ } => self.choose_type(typ) + "*",
            ir::Typing::Array { typ, .. } => self.choose_type(typ) + "*",
            ir::Typing::Struct(ir::Struct { name, .. }) => format!("struct {name}"),
            ir::Typing::Enum(ir::Enum { name, .. }) => format!("enum {name}"),
            ir::Typing::Void => "void".to_string(),
            e => {
                dbg!(e);
                todo!()
            }
        };
    }

    // NOTE: I'm using an option here in case of a function call that returns void,
    // which is not a valid value in LLVM unfortunately.
    pub fn generate_expression(&mut self, expr: &ir::Expression) -> String {
        match expr {
            ir::Expression::Integer { value } => value.to_string(),
            ir::Expression::Float { value } => value.to_string(),
            ir::Expression::StringLiteral { value } => format!("\"{}\"", value),
            ir::Expression::Bool { value } => {
                return if *value { "1" } else { "0" }.to_string();
            }
            ir::Expression::UnaryOperation { operator, operand } => {
                let op = &self.generate_expression(operand);
                match *operator {
                    ir::UnaryOperation::Neg => c::unop(op, c::Unop::Neg),
                    ir::UnaryOperation::BNot => c::unop(op, c::Unop::BNot),
                    ir::UnaryOperation::Not => c::unop(op, c::Unop::Not),
                    ir::UnaryOperation::Addr => c::unop(op, c::Unop::Addr),
                    ir::UnaryOperation::Deref => c::unop(op, c::Unop::Deref),
                }
            }
            ir::Expression::BinaryOperation {
                operator,
                left,
                right,
            } => {
                let lhs = &self.generate_expression(left);
                let rhs = &self.generate_expression(right);
                match *operator {
                    ir::BinaryOperation::Add => c::binop(lhs, rhs, c::Binop::Add),
                    ir::BinaryOperation::Sub => c::binop(lhs, rhs, c::Binop::Sub),
                    ir::BinaryOperation::Mul => c::binop(lhs, rhs, c::Binop::Mul),
                    ir::BinaryOperation::Div => c::binop(lhs, rhs, c::Binop::Div),
                    ir::BinaryOperation::Lt => c::binop(lhs, rhs, c::Binop::Lt),
                    ir::BinaryOperation::Gt => c::binop(lhs, rhs, c::Binop::Gt),
                    ir::BinaryOperation::Le => c::binop(lhs, rhs, c::Binop::Le),
                    ir::BinaryOperation::Ge => c::binop(lhs, rhs, c::Binop::Ge),
                    ir::BinaryOperation::Eq => c::binop(lhs, rhs, c::Binop::Eq),
                    ir::BinaryOperation::Ne => c::binop(lhs, rhs, c::Binop::Ne),
                    ir::BinaryOperation::Assign => c::binop(lhs, rhs, c::Binop::Assign),
                    c => {
                        dbg!(c);
                        todo!()
                    }
                }
            }
            ir::Expression::ArrayLiteral { exprs, typ } => {
                let exprs = exprs.iter().map(|e| self.generate_expression(e));
                let items = c::list(&exprs.collect::<Vec<String>>());
                let typ = self.choose_type(typ);
                return c::array_expr(&typ, &items);
            }
            ir::Expression::FunctionCall {
                function,
                arguments,
            } => match function.as_ref() {
                ir::Expression::Identifier { name } => {
                    let arguments: Vec<String> = arguments
                        .iter()
                        .map(|x| self.generate_expression(x))
                        .collect();
                    let arguments = c::list(arguments.as_slice());
                    return c::function_call_expr(name, &arguments);
                }
                _ => todo!(),
            },
            ir::Expression::Identifier { name } => name.clone(),
            ir::Expression::StructInit { origin, fields } => {
                let name = origin.name.clone();
                let fields = fields
                    .iter()
                    .map(|(f, e)| (f.clone(), self.generate_expression(e)))
                    .collect::<Vec<(String, String)>>();
                return c::struct_expr(&name, &fields);
            }
            ir::Expression::FieldAccess { origin, field } => {
                let lhs = self.generate_expression(origin);
                let rhs = field.clone();
                return c::member_expr(&lhs, &rhs);
            }
        }
    }

    pub fn generate_statement(&mut self, stmt: &mut ir::Statement) -> String {
        let mut output = String::new();
        match stmt {
            ir::Statement::Constant {
                value,
                binding,
                typing,
            } => {
                output.push_str("static ");
                output.push_str(self.choose_type(typing).as_str());
                output.push_str(&binding);
                output.push('=');
                let expr = self.generate_expression(&value);
                output.push_str(&expr);
                output.push(';');
            }
            ir::Statement::FnStatement(stmt) => {
                let r#return = self.choose_type(&stmt.head.ret);
                let name = stmt.head.name.clone();
                let mut arguments = Vec::new();
                for (name, typing) in &stmt.head.arguments {
                    let t = self.choose_type(typing);
                    arguments.push(c::field(&t, name));
                }
                let arguments = c::list(arguments.as_slice());
                let body = stmt
                    .block
                    .iter_mut()
                    .map(|x| self.generate_statement(x))
                    .collect::<Vec<String>>();
                let body = c::statement_list(body.as_slice());
                output.push_str(&c::function_stmt(
                    &r#return,
                    &name,
                    &arguments,
                    stmt.head.variadic,
                    &body,
                ));
            }
            ir::Statement::ExternFnStatement(stmt) => {
                let r#return = self.choose_type(&stmt.ret);
                let name = stmt.name.clone();
                let mut arguments = Vec::new();
                for (name, typing) in &stmt.arguments {
                    let t = self.choose_type(typing);
                    arguments.push(c::field(&t, name));
                }
                let arguments = c::list(arguments.as_slice());
                output.push_str(&c::function_decl_stmt(
                    &r#return,
                    &name,
                    &arguments,
                    stmt.variadic,
                ))
            }
            ir::Statement::StructStatement(stmt) => {
                let fields = stmt
                    .fields
                    .iter()
                    .map(|(k, v)| c::field(&self.choose_type(v), k));
                let fields = fields.collect::<Vec<String>>();
                let body = c::statement_list(&fields);
                output.push_str(&c::struct_stmt(&stmt.name, &body));
            }
            ir::Statement::EnumStatement(stmt) => {
                let doby = c::list(&stmt.variants);
                output.push_str(&c::enum_stmt(&stmt.name, &doby));
            }
            ir::Statement::Variable {
                binding,
                assignment,
                typing,
            } => {
                let typ = self.choose_type(typing);
                let expr = self.generate_expression(&assignment);
                output.push_str(&c::variable_stmt(&typ, binding, &expr));
            }
            ir::Statement::ExpressionStatement(expr) => {
                let e = self.generate_expression(&expr);
                output.push_str(&e);
            }
            ir::Statement::ReturnStatement { value, typing: _ } => {
                let e = value.as_ref().map(|x| self.generate_expression(x));
                output.push_str(&c::return_stmt(e));
            }
            ir::Statement::IfStatement {
                condition,
                block_true,
                block_false,
            } => {
                let comparison = self.generate_expression(&condition);
                let r#true = block_true
                    .iter_mut()
                    .map(|x| self.generate_statement(x))
                    .collect::<Vec<String>>();
                let r#true = c::statement_list(r#true.as_slice());

                let mut r#false = None;
                if !block_false.is_empty() {
                    let f = block_false
                        .iter_mut()
                        .map(|x| self.generate_statement(x))
                        .collect::<Vec<String>>();
                    r#false = Some(c::statement_list(f.as_slice()));
                }
                output.push_str(&c::if_stmt(&comparison, &r#true, r#false));
            }
            ir::Statement::WhileStatement { condition, block } => {
                let comparison = self.generate_expression(&condition);
                let block = block
                    .iter_mut()
                    .map(|x| self.generate_statement(x))
                    .collect::<Vec<String>>();
                let block = c::statement_list(block.as_slice());
                output.push_str(&c::while_stmt(&comparison, &block));
            }
            _ => todo!(),
        };
        return output;
    }

    pub fn go(&mut self) {
        for mut node in std::mem::take(&mut self.input.nodes) {
            let node = self.generate_statement(&mut node);
            self.output.push_str(&node);
            self.output.push_str(";\n");
        }
    }
}
