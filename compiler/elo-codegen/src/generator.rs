use crate::c;
use elo_ir::ir::{self, Program};

pub struct Generator {
    pub input: Program,
    pub output: String,
}

impl Generator {
    pub fn new(input: Program) -> Self {
        Self {
            input: input,
            output: String::from(HEAD),
        }
    }
}

const HEAD: &'static str = "//generated by Elo compiler\n//copyright(c) 2025 Marcio Dantas, Igor Ferreira\n#include<stdint.h>\n";

// fn fnv_hash(text: &str) -> u32 {
//     const FNV_OFFSET_BASIS_32: u32 = 2166136261;
//     const FNV_PRIME_32: u32 = 16777619;
//     let mut hash = FNV_OFFSET_BASIS_32;
//     for byte in text.bytes() {
//         hash = hash.wrapping_mul(FNV_PRIME_32);
//         hash = hash ^ (byte as u32);
//     }
//     hash
// }

// fn mangle_function(name: &str) -> String {
//     if name == "main" {
//         // TODO: Rename this mangling result to be __elo__main
//         //       or something like that when implementing runtime
//         return String::from("main");
//     }
//     return format!("__elo__fn_{name}_{}", fnv_hash(name));
// }

impl Generator {
    pub fn choose_type(&self, t: ir::Typing) -> String {
        return match t {
            ir::Typing::Primitive(ir::Primitive::I128) => "__int128".to_string(),
            ir::Typing::Primitive(ir::Primitive::I64) => "int64_t".to_string(),
            ir::Typing::Primitive(ir::Primitive::I32) => "int32_t".to_string(),
            ir::Typing::Primitive(ir::Primitive::I16) => "int16_t".to_string(),
            ir::Typing::Primitive(ir::Primitive::I8) => "int8_t".to_string(),
            ir::Typing::Primitive(ir::Primitive::Bool) => "bool".to_string(),
            ir::Typing::Primitive(ir::Primitive::U128) => "unsigned __int128".to_string(),
            ir::Typing::Primitive(ir::Primitive::U64) => "uint64_t".to_string(),
            ir::Typing::Primitive(ir::Primitive::U32) => "uint32_t".to_string(),
            ir::Typing::Primitive(ir::Primitive::U16) => "uint16_t".to_string(),
            ir::Typing::Primitive(ir::Primitive::U8) => "uint8_t".to_string(),
            ir::Typing::Primitive(ir::Primitive::F32) => "float".to_string(),
            ir::Typing::Primitive(ir::Primitive::F64) => "double".to_string(),
            // TODO: Make these int and uint to have the same size as the target architecture
            ir::Typing::Primitive(ir::Primitive::Int) => "intptr_t".to_string(),
            ir::Typing::Primitive(ir::Primitive::UInt) => "uintptr_t".to_string(),
            // TODO: Make float have the size as the target architecture
            ir::Typing::Primitive(ir::Primitive::Float) => "float".to_string(),
            ir::Typing::Primitive(ir::Primitive::Str) => "char*".to_string(),
            ir::Typing::Primitive(ir::Primitive::Char) => "uint32_t".to_string(),
            ir::Typing::Pointer { typ } => self.choose_type(*typ) + "*",
            ir::Typing::Void => "void".to_string(),
            _ => todo!(),
        };
    }

    // NOTE: I'm using an option here in case of a function call that returns void,
    // which is not a valid value in LLVM unfortunately.
    pub fn generate_expression(&mut self, expr: &ir::Expression) -> String {
        match expr {
            ir::Expression::Integer { value } => value.to_string(),
            ir::Expression::Float { value } => value.to_string(),
            ir::Expression::StringLiteral { value } => format!("\"{}\"", value),
            ir::Expression::Bool { value } => {
                return if *value { "1" } else { "0" }.to_string();
            }
            ir::Expression::UnaryOperation { operator, operand } => {
                let op = self.generate_expression(operand);
                match *operator {
                    ir::UnaryOperation::Neg => c::build_unop(op, c::Unop::Neg),
                    ir::UnaryOperation::BNot => c::build_unop(op, c::Unop::BNot),
                    ir::UnaryOperation::Not => c::build_unop(op, c::Unop::Not),
                    ir::UnaryOperation::Addr => c::build_unop(op, c::Unop::Addr),
                    // TODO: Implement dereference operator
                }
            }
            ir::Expression::BinaryOperation {
                operator,
                left,
                right,
            } => {
                let lhs = self.generate_expression(left);
                let rhs = self.generate_expression(right);
                match *operator {
                    ir::BinaryOperation::Add => c::build_binop(lhs, rhs, c::Binop::Add),
                    ir::BinaryOperation::Sub => c::build_binop(lhs, rhs, c::Binop::Sub),
                    ir::BinaryOperation::Mul => c::build_binop(lhs, rhs, c::Binop::Mul),
                    ir::BinaryOperation::Div => c::build_binop(lhs, rhs, c::Binop::Div),
                    ir::BinaryOperation::Lt => c::build_binop(lhs, rhs, c::Binop::Lt),
                    ir::BinaryOperation::Gt => c::build_binop(lhs, rhs, c::Binop::Gt),
                    ir::BinaryOperation::Le => c::build_binop(lhs, rhs, c::Binop::Le),
                    ir::BinaryOperation::Ge => c::build_binop(lhs, rhs, c::Binop::Ge),
                    ir::BinaryOperation::Eq => c::build_binop(lhs, rhs, c::Binop::Eq),
                    ir::BinaryOperation::Ne => c::build_binop(lhs, rhs, c::Binop::Ne),
                    ir::BinaryOperation::Assign => c::build_binop(lhs, rhs, c::Binop::Assign),
                    c => {
                        dbg!(c);
                        todo!()
                    }
                }
            }
            ir::Expression::FunctionCall {
                function,
                arguments,
            } => match function.as_ref() {
                ir::Expression::Identifier { name } => {
                    let arguments: Vec<String> = arguments
                        .iter()
                        .map(|x| self.generate_expression(x))
                        .collect();
                    let arguments = c::build_comma_list(arguments.as_slice());
                    return c::build_function_call(name.clone(), arguments);
                }
                _ => todo!(),
            },
            ir::Expression::Identifier { name } => name.clone(),
            _ => todo!(),
        }
    }

    pub fn generate_statement(&mut self, stmt: &mut ir::Statement) -> String {
        let mut output = String::new();
        match stmt {
            ir::Statement::Constant {
                value,
                binding,
                typing,
            } => {
                output.push_str("static ");
                output.push_str(self.choose_type(typing.clone()).as_str());
                output.push_str(&binding);
                output.push('=');
                let expr = self.generate_expression(&value);
                output.push_str(&expr);
                output.push(';');
            }
            ir::Statement::FnStatement(stmt) => {
                let r#return = self.choose_type(stmt.ret.clone());
                let name = stmt.name.clone();
                let mut arguments = Vec::new();
                for i in &stmt.arguments {
                    let t = self.choose_type(i.typing.clone());
                    let n = i.name.clone();
                    arguments.push(c::build_typed_field(t, n));
                }
                let arguments = c::build_comma_list(arguments.as_slice());
                let body = stmt
                    .block
                    .iter_mut()
                    .map(|x| self.generate_statement(x))
                    .collect::<Vec<String>>();
                let body = c::build_statement_list(body.as_slice());
                output.push_str(&c::build_function_definition(
                    r#return,
                    name,
                    arguments,
                    stmt.variadic,
                    body,
                ));
            }
            ir::Statement::ExternFnStatement(stmt) => {
                let r#return = self.choose_type(stmt.ret.clone());
                let name = stmt.name.clone();
                let mut arguments = Vec::new();
                for i in &stmt.arguments {
                    let t = self.choose_type(i.typing.clone());
                    let n = i.name.clone();
                    arguments.push(c::build_typed_field(t, n));
                }
                let arguments = c::build_comma_list(arguments.as_slice());
                output.push_str(&c::build_function_declaration(
                    r#return,
                    name,
                    arguments,
                    stmt.variadic,
                ))
            }
            ir::Statement::StructStatement(_stmt) => {
                todo!();
            }
            ir::Statement::EnumStatement(stmt) => {
                let doby = c::build_comma_list(&stmt.variants);
                output.push_str(&c::build_enum_definition(stmt.name.clone(), doby));
            }
            ir::Statement::Variable {
                binding,
                assignment,
                typing,
            } => {
                let typ = self.choose_type(typing.clone());
                let expr = self.generate_expression(&assignment);
                output.push_str(&c::build_variable_definition(typ, binding.clone(), expr));
            }
            ir::Statement::ExpressionStatement(expr) => {
                let e = self.generate_expression(&expr);
                output.push_str(&e);
            }
            ir::Statement::ReturnStatement { value, typing: _ } => {
                let e = value.as_ref().map(|x| self.generate_expression(x));
                output.push_str(&c::build_return(e));
            }
            ir::Statement::IfStatement {
                condition,
                block_true,
                block_false,
            } => {
                let comparison = self.generate_expression(&condition);
                let r#true = block_true
                    .iter_mut()
                    .map(|x| self.generate_statement(x))
                    .collect::<Vec<String>>();
                let r#true = c::build_statement_list(r#true.as_slice());

                let mut r#false = None;
                if !block_false.is_empty() {
                    let f = block_false
                        .iter_mut()
                        .map(|x| self.generate_statement(x))
                        .collect::<Vec<String>>();
                    r#false = Some(c::build_statement_list(f.as_slice()));
                }
                output.push_str(&c::build_if(comparison, r#true, r#false));
            }
            ir::Statement::WhileStatement { condition, block } => {
                let comparison = self.generate_expression(&condition);
                let block = block
                    .iter_mut()
                    .map(|x| self.generate_statement(x))
                    .collect::<Vec<String>>();
                let block = c::build_statement_list(block.as_slice());
                output.push_str(&c::build_while(comparison, block));
            }
            _ => todo!(),
        };
        return output;
    }

    pub fn go(&mut self) {
        for mut node in std::mem::take(&mut self.input.nodes) {
            let node = self.generate_statement(&mut node);
            self.output.push_str(&node);
            self.output.push_str(";\n");
        }
    }
}
