use crate::c;
use elo_ir::cir::{self, Program};

pub struct Generator {
    pub input: Program,
    pub body: String,
    pub head: String,
    tuples: Vec<Vec<cir::Typing>>,
}

impl Generator {
    pub fn new(input: Program) -> Self {
        Self {
            input: input,
            body: String::new(),
            head: String::from(HEAD),
            tuples: Vec::new(),
        }
    }
}

const HEAD: &'static str = "//generated by Elo compiler\n//copyright(c) 2025 Marcio Dantas, Igor Ferreira\n#include<stdint.h>\n";

fn fnv_hash(text: &str) -> u32 {
    const FNV_OFFSET_BASIS_32: u32 = 2166136261;
    const FNV_PRIME_32: u32 = 16777619;
    let mut hash = FNV_OFFSET_BASIS_32;
    for byte in text.bytes() {
        hash = hash.wrapping_mul(FNV_PRIME_32);
        hash = hash ^ (byte as u32);
    }
    hash
}

fn mangle_function(name: &str) -> String {
    if name == "main" { // python reference
        // TODO: Rename this mangling result to be __elo__main
        //       or something like that when implementing runtime
        return String::from("main");
    }
    return format!("_fn_{name}_{}", fnv_hash(name));
}

fn mangle_enum(name: &str) -> String {
    return format!("_enum_{name}_{}", fnv_hash(name));
}

fn mangle_enum_variant(enum_name: &str, variant: &str) -> String {
    return format!("_enum_{enum_name}_{variant}_{}", fnv_hash(variant));
}

fn mangle_struct(name: &str) -> String {
    return format!("_struct_{name}_{}", fnv_hash(name));
}

fn mangle_tuple(no: usize) -> String {
    return format!("_tuple{no}_{}", fnv_hash(&no.to_string()));
}


impl Generator {
    pub fn get_tuple(&mut self, types: &Vec<cir::Typing>) -> String {
        let mut tuple_index = None;
        for (index, tuple) in self.tuples.iter().enumerate() {
            if tuple == types {
                tuple_index = Some(index);
            }
        }
        if let Some(i) = tuple_index {
            return mangle_tuple(i);
        } else {
            self.tuples.push(types.clone());
            let i = self.tuples.len() - 1;
            let mut body = String::new();
            for (i, j) in types.iter().enumerate() {
                body.push_str(&format!("{} t{i};\n", self.choose_type(j)));
            }
            let struct_name = mangle_tuple(i);
            self.head.push_str(&c::struct_stmt(&struct_name, &body));
            return struct_name;
        }
    }

    pub fn choose_type(&mut self, t: &cir::Typing) -> String {
        return match t {
            cir::Typing::Primitive(cir::Primitive::I64) => "int64_t".to_string(),
            cir::Typing::Primitive(cir::Primitive::I32) => "int32_t".to_string(),
            cir::Typing::Primitive(cir::Primitive::I16) => "int16_t".to_string(),
            cir::Typing::Primitive(cir::Primitive::I8) => "int8_t".to_string(),
            cir::Typing::Primitive(cir::Primitive::Bool) => "bool".to_string(),
            cir::Typing::Primitive(cir::Primitive::U64) => "uint64_t".to_string(),
            cir::Typing::Primitive(cir::Primitive::U32) => "uint32_t".to_string(),
            cir::Typing::Primitive(cir::Primitive::U16) => "uint16_t".to_string(),
            cir::Typing::Primitive(cir::Primitive::U8) => "uint8_t".to_string(),
            cir::Typing::Primitive(cir::Primitive::F32) => "float".to_string(),
            cir::Typing::Primitive(cir::Primitive::F64) => "double".to_string(),
            // TODO: Make these int and uint to have the same size as the target architecture
            cir::Typing::Primitive(cir::Primitive::Int) => "intptr_t".to_string(),
            cir::Typing::Primitive(cir::Primitive::UInt) => "uintptr_t".to_string(),
            // TODO: Make float have the size as the target architecture
            cir::Typing::Primitive(cir::Primitive::Float) => "float".to_string(),
            cir::Typing::Primitive(cir::Primitive::Str) => "char*".to_string(),
            cir::Typing::Primitive(cir::Primitive::Char) => "uint32_t".to_string(),
            cir::Typing::Pointer { typ, mutable: _ } => self.choose_type(typ) + "*",
            cir::Typing::Array { typ, .. } => self.choose_type(typ) + "*",
            cir::Typing::Struct(cir::Struct { name, .. }) => format!("struct {}", mangle_struct(name)),
            cir::Typing::Enum(cir::Enum { name, .. }) => format!("enum {}", mangle_enum(name)),
            cir::Typing::Void => "void".to_string(),
            cir::Typing::Tuple { types } => format!("struct {}", self.get_tuple(types)),
            _ => {
                todo!()
            }
        };
    }

    // NOTE: I'm using an option here in case of a function call that returns void,
    // which is not a valid value in LLVM unfortunately.
    // Not using the option now since we don't use LLVM anymore
    pub fn generate_expression(&mut self, expr: &cir::Expression) -> String {
        match &expr.data {
            cir::ExpressionData::Integer { value } => value.to_string(),
            cir::ExpressionData::Float { value } => value.to_string(),
            cir::ExpressionData::StringLiteral { value } => c::string_expr(value),
            cir::ExpressionData::Bool { value } => {
                return if *value { "1" } else { "0" }.to_string();
            }
            cir::ExpressionData::Tuple { exprs, types } => {
                let struct_name = self.get_tuple(types);
                let fields = exprs
                    .iter()
                    .map(|e| self.generate_expression(e))
                    .collect::<Vec<String>>();
                return c::struct_expr_ordered(&struct_name, &fields);
            },
            cir::ExpressionData::UnaryOperation { operator, operand } => {
                let op = &self.generate_expression(operand);
                match *operator {
                    cir::UnaryOperation::Neg => c::unop_expr(op, c::Unop::Neg),
                    cir::UnaryOperation::BNot => c::unop_expr(op, c::Unop::BNot),
                    cir::UnaryOperation::Not => c::unop_expr(op, c::Unop::Not),
                    cir::UnaryOperation::Addr => c::unop_expr(op, c::Unop::Addr),
                    cir::UnaryOperation::Deref => c::unop_expr(op, c::Unop::Deref),
                }
            }
            cir::ExpressionData::BinaryOperation {
                operator,
                left,
                right,
                ..
            } => {
                let lhs = &self.generate_expression(left);
                let rhs = &self.generate_expression(right);
                match *operator {
                    cir::BinaryOperation::Add => c::binop_expr(lhs, rhs, c::Binop::Add),
                    cir::BinaryOperation::Sub => c::binop_expr(lhs, rhs, c::Binop::Sub),
                    cir::BinaryOperation::Mul => c::binop_expr(lhs, rhs, c::Binop::Mul),
                    cir::BinaryOperation::Div => c::binop_expr(lhs, rhs, c::Binop::Div),
                    cir::BinaryOperation::Lt => c::binop_expr(lhs, rhs, c::Binop::Lt),
                    cir::BinaryOperation::Gt => c::binop_expr(lhs, rhs, c::Binop::Gt),
                    cir::BinaryOperation::Le => c::binop_expr(lhs, rhs, c::Binop::Le),
                    cir::BinaryOperation::Ge => c::binop_expr(lhs, rhs, c::Binop::Ge),
                    cir::BinaryOperation::Eq => c::binop_expr(lhs, rhs, c::Binop::Eq),
                    cir::BinaryOperation::Ne => c::binop_expr(lhs, rhs, c::Binop::Ne),
                    cir::BinaryOperation::Assign => c::binop_expr(lhs, rhs, c::Binop::Assign),
                    c => {
                        dbg!(c);
                        todo!()
                    }
                }
            }
            cir::ExpressionData::ArrayLiteral { exprs, typ } => {
                let exprs = exprs.iter().map(|e| self.generate_expression(e));
                let items = c::list(&exprs.collect::<Vec<String>>());
                let typ = self.choose_type(typ);
                return c::array_expr(&typ, &items);
            }
            cir::ExpressionData::FunctionCall {
                function,
                arguments,
                extrn
            } => {
                if let cir::ExpressionData::Identifier { ref name } = (**function).data {
                    let arguments: Vec<String> = arguments
                        .iter()
                        .map(|x| self.generate_expression(x))
                        .collect();
                    let arguments = c::list(arguments.as_slice());
                    let fn_name = if *extrn { name } else { &mangle_function(name) };
                    return c::function_call_expr(fn_name, &arguments);
                } else {
                    todo!("implement other cases for function calls");
                }
            },
            cir::ExpressionData::Identifier { name } => name.clone(),
            cir::ExpressionData::StructInit { origin, fields } => {
                let name = origin.name.clone();
                let fields = fields
                    .iter()
                    .map(|(f, e)| (f.clone(), self.generate_expression(e)))
                    .collect::<Vec<(String, String)>>();
                return c::struct_expr(&name, &fields);
            }
            cir::ExpressionData::TupleAccess { origin, field } => {
                let field = &format!("t{field}");
                return c::member_expr(&self.generate_expression(origin), field);
            },
            cir::ExpressionData::ArraySubscript { origin, index } => {
                let origin = self.generate_expression(origin);
                let index = self.generate_expression(index);
                return c::subscript_expr(&origin, &index);
            }
            cir::ExpressionData::FieldAccess { origin, field } => {
                let lhs = self.generate_expression(origin);
                let rhs = field.clone();
                return c::member_expr(&lhs, &rhs);
            }
            cir::ExpressionData::EnumVariant { origin, variant } => {
                return mangle_enum_variant(origin, variant);
            }
        }
    }

    pub fn generate_statement(&mut self, stmt: &mut cir::Statement) -> String {
        let mut output = String::new();
        match &mut stmt.kind {
            cir::StatementKind::Constant {
                value,
                binding,
                typing,
            } => {
                self.head.push_str("static const ");
                let x = self.choose_type(typing);
                self.head.push_str(x.as_str());
                self.head.push_str(&binding);
                self.head.push('=');
                let expr = self.generate_expression(&value);
                self.head.push_str(&expr);
                self.head.push_str(";\n");
            }
            cir::StatementKind::FnStatement(stmt) => {
                let r#return = self.choose_type(&stmt.head.ret);
                let name = stmt.head.name.clone();
                let mut arguments = Vec::new();
                for (name, typing) in &stmt.head.arguments {
                    let t = self.choose_type(typing);
                    arguments.push(c::field(&t, name));
                }
                let arguments = c::list(arguments.as_slice());
                let body = stmt
                    .block
                    .iter_mut()
                    .map(|x| self.generate_statement(x))
                    .collect::<Vec<String>>();
                let name = &mangle_function(&name);
                let body = c::statement_list(body.as_slice());
                self.head.push_str(&c::function_decl_stmt(&r#return, name, &arguments, false));
                output.push_str(&c::function_stmt(
                    &r#return,
                    name,
                    &arguments,
                    stmt.head.variadic,
                    &body,
                ));
            }
            cir::StatementKind::ExternFnStatement(stmt) => {
                let r#return = self.choose_type(&stmt.ret);
                let name = stmt.name.clone();
                let mut arguments = Vec::new();
                for (name, typing) in &stmt.arguments {
                    let t = self.choose_type(typing);
                    arguments.push(c::field(&t, name));
                }
                let arguments = c::list(arguments.as_slice());
                self.head.push_str(&c::function_decl_stmt(
                    &r#return,
                    &name,
                    &arguments,
                    stmt.variadic,
                ));
            }
            cir::StatementKind::StructStatement(stmt) => {
                let fields = stmt
                    .fields
                    .iter()
                    .map(|(k, v)| c::struct_field(&self.choose_type(v), k));
                let fields = fields.collect::<Vec<String>>();
                let body = c::statement_list(&fields);
                self.head.push_str(&c::struct_stmt(&mangle_struct(&stmt.name), &body));
            }
            cir::StatementKind::EnumStatement(stmt) => {
                let vars: Vec<String> = stmt.variants.iter().map(|x| mangle_enum_variant(&stmt.name, x)).collect();
                let doby = c::list(&vars);
                self.head.push_str(&c::enum_stmt(&mangle_enum(&stmt.name), &doby));
            }
            // BODY STATEMENTS //
            cir::StatementKind::Variable {
                binding,
                assignment,
                typing,
                ..
            } => {
                let typ = self.choose_type(typing);
                let expr = self.generate_expression(&assignment);
                output.push_str(&c::variable_stmt(&typ, binding, &expr));
            }
            cir::StatementKind::ExpressionStatement(expr) => {
                let e = self.generate_expression(&expr);
                output.push_str(&c::expr_stmt(&e));
            }
            cir::StatementKind::ReturnStatement { value, .. } => {
                let e = value.as_ref().map(|x| self.generate_expression(x));
                output.push_str(&c::return_stmt(e));
            }
            cir::StatementKind::IfStatement {
                condition,
                block_true,
                block_false,
                ..
            } => {
                let comparison = self.generate_expression(&condition);
                let r#true = block_true
                    .iter_mut()
                    .map(|x| self.generate_statement(x))
                    .collect::<Vec<String>>();
                let r#true = c::statement_list(r#true.as_slice());

                let mut r#false = None;
                if !block_false.is_empty() {
                    let f = block_false
                        .iter_mut()
                        .map(|x| self.generate_statement(x))
                        .collect::<Vec<String>>();
                    r#false = Some(c::statement_list(f.as_slice()));
                }
                output.push_str(&c::if_stmt(&comparison, &r#true, r#false));
            }
            cir::StatementKind::WhileStatement { condition, block } => {
                let comparison = self.generate_expression(&condition);
                let block = block
                    .iter_mut()
                    .map(|x| self.generate_statement(x))
                    .collect::<Vec<String>>();
                let block = c::statement_list(block.as_slice());
                output.push_str(&c::while_stmt(&comparison, &block));
            }
        };
        return output;
    }

    pub fn go(&mut self) {
        for mut node in std::mem::take(&mut self.input.nodes) {
            let out = &self.generate_statement(&mut node);
            self.body.push_str(out);
        }
    }
}
